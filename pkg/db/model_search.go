// Code generated by mfd-generator v0.6.0; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"time"

	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type CabinetSearch struct {
	search

	ID               *int
	Name             *string
	ClientID         *string
	Key              *string
	Marketplace      *string
	Type             *string
	SheetLink        *string
	StatusID         *int
	IDs              []int
	NameILike        *string
	ClientIDILike    *string
	KeyILike         *string
	MarketplaceILike *string
	TypeILike        *string
	SheetLinkILike   *string
}

func (cs *CabinetSearch) Apply(query *orm.Query) *orm.Query {
	if cs == nil {
		return query
	}
	if cs.ID != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.ID, cs.ID)
	}
	if cs.Name != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.Name, cs.Name)
	}
	if cs.ClientID != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.ClientID, cs.ClientID)
	}
	if cs.Key != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.Key, cs.Key)
	}
	if cs.Marketplace != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.Marketplace, cs.Marketplace)
	}
	if cs.Type != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.Type, cs.Type)
	}
	if cs.SheetLink != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.SheetLink, cs.SheetLink)
	}
	if cs.StatusID != nil {
		cs.where(query, Tables.Cabinet.Alias, Columns.Cabinet.StatusID, cs.StatusID)
	}
	if len(cs.IDs) > 0 {
		Filter{Columns.Cabinet.ID, cs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if cs.NameILike != nil {
		Filter{Columns.Cabinet.Name, *cs.NameILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.ClientIDILike != nil {
		Filter{Columns.Cabinet.ClientID, *cs.ClientIDILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.KeyILike != nil {
		Filter{Columns.Cabinet.Key, *cs.KeyILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.MarketplaceILike != nil {
		Filter{Columns.Cabinet.Marketplace, *cs.MarketplaceILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.TypeILike != nil {
		Filter{Columns.Cabinet.Type, *cs.TypeILike, SearchTypeILike, false}.Apply(query)
	}
	if cs.SheetLinkILike != nil {
		Filter{Columns.Cabinet.SheetLink, *cs.SheetLinkILike, SearchTypeILike, false}.Apply(query)
	}

	cs.apply(query)

	return query
}

func (cs *CabinetSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if cs == nil {
			return query, nil
		}
		return cs.Apply(query), nil
	}
}

type OrderSearch struct {
	search

	ID                 *int
	PostingNumber      *string
	Article            *string
	Count              *int
	CabinetID          *int
	CreatedAt          *time.Time
	StatusID           *int
	IDs                []int
	PostingNumberILike *string
	ArticleILike       *string
}

func (os *OrderSearch) Apply(query *orm.Query) *orm.Query {
	if os == nil {
		return query
	}
	if os.ID != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.ID, os.ID)
	}
	if os.PostingNumber != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.PostingNumber, os.PostingNumber)
	}
	if os.Article != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.Article, os.Article)
	}
	if os.Count != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.Count, os.Count)
	}
	if os.CabinetID != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.CabinetID, os.CabinetID)
	}
	if os.CreatedAt != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.CreatedAt, os.CreatedAt)
	}
	if os.StatusID != nil {
		os.where(query, Tables.Order.Alias, Columns.Order.StatusID, os.StatusID)
	}
	if len(os.IDs) > 0 {
		Filter{Columns.Order.ID, os.IDs, SearchTypeArray, false}.Apply(query)
	}
	if os.PostingNumberILike != nil {
		Filter{Columns.Order.PostingNumber, *os.PostingNumberILike, SearchTypeILike, false}.Apply(query)
	}
	if os.ArticleILike != nil {
		Filter{Columns.Order.Article, *os.ArticleILike, SearchTypeILike, false}.Apply(query)
	}

	os.apply(query)

	return query
}

func (os *OrderSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if os == nil {
			return query, nil
		}
		return os.Apply(query), nil
	}
}

type StockSearch struct {
	search

	ID           *int
	Article      *string
	UpdatedAt    *time.Time
	CountFbo     *int
	CountFbs     *int
	CabinetID    *int
	IDs          []int
	ArticleILike *string
}

func (ss *StockSearch) Apply(query *orm.Query) *orm.Query {
	if ss == nil {
		return query
	}
	if ss.ID != nil {
		ss.where(query, Tables.Stock.Alias, Columns.Stock.ID, ss.ID)
	}
	if ss.Article != nil {
		ss.where(query, Tables.Stock.Alias, Columns.Stock.Article, ss.Article)
	}
	if ss.UpdatedAt != nil {
		ss.where(query, Tables.Stock.Alias, Columns.Stock.UpdatedAt, ss.UpdatedAt)
	}
	if ss.CountFbo != nil {
		ss.where(query, Tables.Stock.Alias, Columns.Stock.CountFbo, ss.CountFbo)
	}
	if ss.CountFbs != nil {
		ss.where(query, Tables.Stock.Alias, Columns.Stock.CountFbs, ss.CountFbs)
	}
	if ss.CabinetID != nil {
		ss.where(query, Tables.Stock.Alias, Columns.Stock.CabinetID, ss.CabinetID)
	}
	if len(ss.IDs) > 0 {
		Filter{Columns.Stock.ID, ss.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ss.ArticleILike != nil {
		Filter{Columns.Stock.Article, *ss.ArticleILike, SearchTypeILike, false}.Apply(query)
	}

	ss.apply(query)

	return query
}

func (ss *StockSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ss == nil {
			return query, nil
		}
		return ss.Apply(query), nil
	}
}

type UserSearch struct {
	search

	ID             *int
	TgID           *int64
	IsAdmin        *bool
	StatusID       *int
	Login          *string
	Password       *string
	AuthKey        *string
	CreatedAt      *time.Time
	LastActivityAt *time.Time
	IDs            []int
	LoginILike     *string
	AuthKeyILike   *string
}

func (us *UserSearch) Apply(query *orm.Query) *orm.Query {
	if us == nil {
		return query
	}
	if us.ID != nil {
		us.where(query, Tables.User.Alias, Columns.User.ID, us.ID)
	}
	if us.TgID != nil {
		us.where(query, Tables.User.Alias, Columns.User.TgID, us.TgID)
	}
	if us.IsAdmin != nil {
		us.where(query, Tables.User.Alias, Columns.User.IsAdmin, us.IsAdmin)
	}
	if us.StatusID != nil {
		us.where(query, Tables.User.Alias, Columns.User.StatusID, us.StatusID)
	}
	if us.Login != nil {
		us.where(query, Tables.User.Alias, Columns.User.Login, us.Login)
	}
	if us.Password != nil {
		us.where(query, Tables.User.Alias, Columns.User.Password, us.Password)
	}
	if us.AuthKey != nil {
		us.where(query, Tables.User.Alias, Columns.User.AuthKey, us.AuthKey)
	}
	if us.CreatedAt != nil {
		us.where(query, Tables.User.Alias, Columns.User.CreatedAt, us.CreatedAt)
	}
	if us.LastActivityAt != nil {
		us.where(query, Tables.User.Alias, Columns.User.LastActivityAt, us.LastActivityAt)
	}
	if len(us.IDs) > 0 {
		Filter{Columns.User.ID, us.IDs, SearchTypeArray, false}.Apply(query)
	}
	if us.LoginILike != nil {
		Filter{Columns.User.Login, *us.LoginILike, SearchTypeILike, false}.Apply(query)
	}
	if us.AuthKeyILike != nil {
		Filter{Columns.User.AuthKey, *us.AuthKeyILike, SearchTypeILike, false}.Apply(query)
	}

	us.apply(query)

	return query
}

func (us *UserSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if us == nil {
			return query, nil
		}
		return us.Apply(query), nil
	}
}

type ReviewSearch struct {
	search

	ID                *int
	CabinetID         *int
	ExternalID        *string
	Text              *string
	Pros              *string
	Cons              *string
	Valuation         *int
	Answer            *string
	Article           *string
	CreatedAt         *time.Time
	StatusID          *int
	CustomerName      *string
	IDs               []int
	ExternalIDILike   *string
	ExternalIDs       []string
	TextILike         *string
	ProsILike         *string
	ConsILike         *string
	AnswerILike       *string
	ArticleILike      *string
	CustomerNameILike *string
}

func (rs *ReviewSearch) Apply(query *orm.Query) *orm.Query {
	if rs == nil {
		return query
	}
	if rs.ID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.ID, rs.ID)
	}
	if rs.CabinetID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.CabinetID, rs.CabinetID)
	}
	if rs.ExternalID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.ExternalID, rs.ExternalID)
	}
	if rs.Text != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Text, rs.Text)
	}
	if rs.Pros != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Pros, rs.Pros)
	}
	if rs.Cons != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Cons, rs.Cons)
	}
	if rs.Valuation != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Valuation, rs.Valuation)
	}
	if rs.Answer != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Answer, rs.Answer)
	}
	if rs.Article != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Article, rs.Article)
	}
	if rs.CreatedAt != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.CreatedAt, rs.CreatedAt)
	}
	if rs.StatusID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.StatusID, rs.StatusID)
	}
	if rs.CustomerName != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.CustomerName, rs.CustomerName)
	}
	if len(rs.IDs) > 0 {
		Filter{Columns.Review.ID, rs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if rs.ExternalIDILike != nil {
		Filter{Columns.Review.ExternalID, *rs.ExternalIDILike, SearchTypeILike, false}.Apply(query)
	}
	if len(rs.ExternalIDs) > 0 {
		Filter{Columns.Review.ExternalID, rs.ExternalIDs, SearchTypeArray, false}.Apply(query)
	}
	if rs.TextILike != nil {
		Filter{Columns.Review.Text, *rs.TextILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.ProsILike != nil {
		Filter{Columns.Review.Pros, *rs.ProsILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.ConsILike != nil {
		Filter{Columns.Review.Cons, *rs.ConsILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.AnswerILike != nil {
		Filter{Columns.Review.Answer, *rs.AnswerILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.ArticleILike != nil {
		Filter{Columns.Review.Article, *rs.ArticleILike, SearchTypeILike, false}.Apply(query)
	}
	if rs.CustomerNameILike != nil {
		Filter{Columns.Review.CustomerName, *rs.CustomerNameILike, SearchTypeILike, false}.Apply(query)
	}

	rs.apply(query)

	return query
}

func (rs *ReviewSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if rs == nil {
			return query, nil
		}
		return rs.Apply(query), nil
	}
}
