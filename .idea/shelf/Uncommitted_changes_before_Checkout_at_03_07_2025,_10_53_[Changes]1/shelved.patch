Index: pkg/bot/handlers/handlers_ozon.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bot\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tbotlib \"github.com/go-telegram/bot\"\n\t\"github.com/go-telegram/bot/models\"\n\t\"github.com/xuri/excelize/v2\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"tradebot/api/ozon\"\n\t\"tradebot/db\"\n\t\"tradebot/pkg/fbsPrinter\"\n\t\"tradebot/pkg/marketplaces/OZON\"\n)\n\nfunc createCabinetsMarkup(cabinets []db.Cabinet, page int, hasNext bool) models.InlineKeyboardMarkup {\n\tvar keyboard [][]models.InlineKeyboardButton\n\tvar row []models.InlineKeyboardButton\n\tvar button models.InlineKeyboardButton\n\tfor _, cabinet := range cabinets {\n\t\trow = []models.InlineKeyboardButton{}\n\t\tbutton = models.InlineKeyboardButton{Text: cabinet.Name, CallbackData: fmt.Sprintf(\"%v%v\", CallbackSelectCabinetHandler, cabinet.ID)}\n\t\trow = append(row, button)\n\n\t\tkeyboard = append(keyboard, row)\n\t}\n\n\t//Добавление кнопок для пагинации\n\trow = []models.InlineKeyboardButton{}\n\tif page > 1 {\n\t\tbutton = models.InlineKeyboardButton{Text: \"⬅\uFE0F\", CallbackData: CallbackOzonCabinetsHandler + fmt.Sprintf(\"%v\", page-1)}\n\t\trow = append(row, button)\n\t}\n\n\tif hasNext {\n\t\tbutton = models.InlineKeyboardButton{Text: \"➡\uFE0F\", CallbackData: CallbackOzonCabinetsHandler + fmt.Sprintf(\"%v\", page+1)}\n\t\trow = append(row, button)\n\t}\n\n\tif row != nil {\n\t\tkeyboard = append(keyboard, row)\n\t}\n\n\t//row = []models.InlineKeyboardButton{}\n\t//button = models.InlineKeyboardButton{Text: \"Добавить аккаунт\", CallbackData: addParserCallback}\n\t//row = append(row, button)\n\t//keyboard = append(keyboard, row)\n\n\trow = []models.InlineKeyboardButton{}\n\tbutton = models.InlineKeyboardButton{Text: \"Назад\", CallbackData: CallbackStartHandler}\n\trow = append(row, button)\n\tkeyboard = append(keyboard, row)\n\n\tmarkup := models.InlineKeyboardMarkup{\n\t\tInlineKeyboard: keyboard,\n\t}\n\treturn markup\n}\n\nfunc (m *Manager) ozonHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\tmessageId := update.CallbackQuery.Message.Message.ID\n\n\tvar cabinets []db.Cabinet\n\t// Смотрим есть ли артикул в бд\n\tresult := m.db.Where(`\"marketplace\" = ?`, \"ozon\").Find(&cabinets)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\ttext := \"Выберите кабинет\"\n\tmarkup := createCabinetsMarkup(cabinets, 0, false)\n\n\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{ChatID: chatId, MessageID: messageId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) ozonCabinetHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\tmessageId := update.CallbackQuery.Message.Message.ID\n\n\tparts := strings.Split(update.CallbackQuery.Data, \"_\")\n\tcabinetId := parts[1]\n\n\ttext := \"Кабинет Озон\"\n\n\tvar buttonsRow, buttonBack []models.InlineKeyboardButton\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Вчерашние заказы\", CallbackData: fmt.Sprintf(\"%v%v\", CallbackOzonOrdersHandler, cabinetId)})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Анализ\", CallbackData: fmt.Sprintf(\"%v%v\", CallbackOzonStocksHandler, cabinetId)})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Этикетки FBS\", CallbackData: fmt.Sprintf(\"%v%v\", CallbackOzonStickersHandler, cabinetId)})\n\n\tbuttonBack = append(buttonBack, models.InlineKeyboardButton{Text: \"Назад\", CallbackData: CallbackOzonHandler})\n\n\tallButtons := [][]models.InlineKeyboardButton{buttonsRow, buttonBack}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\n\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{ChatID: chatId, MessageID: messageId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) ozonOrdersHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\t//parts := strings.Split(update.CallbackQuery.Data, \"_\")\n\t//cabinetId := parts[1]\n\n\tvar cabinets []db.Cabinet\n\n\tresult := m.db.Where(`\"marketplace\" = ?`, \"ozon\").Find(&cabinets)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\ttitleRange := \"!A1\"\n\tfbsRange := \"!A2:B1000\"\n\tfboRange := \"!D2:E1000\"\n\treturnsRange := \"!G2:H1000\"\n\n\tmaxValuesCount, err := OZON.NewService(cabinets[0]).GetOrdersAndReturnsManager().WriteToGoogleSheets(titleRange, fbsRange, fboRange, returnsRange)\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\tmaxValuesCount += 3\n\ttitleRange = fmt.Sprintf(\"!A%v\", maxValuesCount)\n\n\tmaxValuesCount++\n\tfbsRange = fmt.Sprintf(\"!A%v:B%v\", maxValuesCount, maxValuesCount+1000)\n\tfboRange = fmt.Sprintf(\"!D%v:E%v\", maxValuesCount, maxValuesCount+1000)\n\treturnsRange = fmt.Sprintf(\"!G%v:H%v\", maxValuesCount, maxValuesCount+1000)\n\n\t_, err = OZON.NewService(cabinets[1]).GetOrdersAndReturnsManager().WriteToGoogleSheets(titleRange, fbsRange, fboRange, returnsRange)\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\tlog.Printf(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\t_, err = SendTextMessage(ctx, bot, chatId, \"Заказы озон за вчерашний день были внесены\")\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\nfunc (m *Manager) ozonStocksHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\n\tK := 1.5\n\n\tchatId := update.CallbackQuery.From.ID\n\n\tparts := strings.Split(update.CallbackQuery.Data, \"_\")\n\tcabinetId := parts[1]\n\n\tvar cabinet db.Cabinet\n\n\tresult := m.db.Where(`\"cabinetsId\" = ?`, cabinetId).Find(&cabinet)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\tpostings := OZON.NewService(cabinet).GetStocksManager().GetPostings()\n\n\tstocks := OZON.NewService(cabinet).GetStocksManager().GetStocks()\n\n\tfilePath, err := generateExcelOzon(postings, stocks, K, \"ozon\")\n\tif err != nil {\n\t\tlog.Println(\"Ошибка при создании Excel:\", err)\n\t\treturn\n\t}\n\n\terr = SendMediaMessage(ctx, bot, chatId, filePath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tos.Remove(filePath)\n\n}\n\n// Хендрер для \"FBS\"\nfunc (m *Manager) ozonStickersHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\tmessageId := update.CallbackQuery.Message.Message.ID\n\n\tparts := strings.Split(update.CallbackQuery.Data, \"_\")\n\tcabinetId := parts[1]\n\n\tvar cabinet db.Cabinet\n\n\tresult := m.db.Where(`\"cabinetsId\" = ?`, cabinetId).Find(&cabinet)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\ttext := \"Печать FBS стикеров. Выберите, какие стикеры распечатать\"\n\n\tvar buttonsRow, buttonBack []models.InlineKeyboardButton\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Новые\", CallbackData: fmt.Sprintf(\"%v%v_%v\", CallbackOzonPrintStickersHandler, cabinetId, OZON.NewLabels)})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Все из сборки\", CallbackData: fmt.Sprintf(\"%v%v_%v\", CallbackOzonPrintStickersHandler, cabinetId, OZON.AllLabels)})\n\tbuttonBack = append(buttonBack, models.InlineKeyboardButton{Text: \"Назад\", CallbackData: fmt.Sprintf(\"%v%v\", CallbackSelectCabinetHandler, cabinetId)})\n\n\tallButtons := [][]models.InlineKeyboardButton{buttonsRow, buttonBack}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\n\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{ChatID: chatId, MessageID: messageId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n}\n\n// Хендлер для печати стикеров \"FBS\"\nfunc (m *Manager) ozonPrintStickers(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\tparts := strings.Split(update.CallbackQuery.Data, \"_\")\n\tcabinetId := parts[1]\n\tflag := parts[2]\n\tvar err error\n\tvar cabinet db.Cabinet\n\n\tresult := m.db.Where(`\"cabinetsId\" = ?`, cabinetId).Find(&cabinet)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\tnewOrders := ozon.PostingslistFbs{}\n\n\tprintedOrdersMap := make(map[string]struct{})\n\tvar printedOrders []db.Order\n\n\tresult = m.db.Where(`\"marketplace\" = ?`, \"ozon\").Find(&printedOrders)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\tfor _, order := range printedOrders {\n\t\tprintedOrdersMap[order.PostingNumber] = struct{}{}\n\t}\n\n\tmanager := OZON.NewService(cabinet).GetStickersFBSManager(printedOrdersMap)\n\n\tvar filePaths []string\n\tdone := make(chan []string)\n\tprogressChan := make(chan fbsPrinter.Progress)\n\terrChan := make(chan error)\n\n\tdefer func() {\n\t\tclose(done)\n\t\tclose(progressChan)\n\t\tclose(errChan)\n\t}()\n\n\tswitch flag {\n\tcase OZON.AllLabels:\n\t\t{\n\t\t\tgo func() {\n\t\t\t\tfilePaths, err = manager.GetAllLabels(progressChan)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"Ошибка при получении файла:\", err)\n\t\t\t\t\terrChan <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdone <- filePaths\n\t\t\t}()\n\n\t\t}\n\n\tcase OZON.NewLabels:\n\t\t{\n\t\t\tgo func() {\n\t\t\t\tfilePaths, newOrders, err = manager.GetNewLabels(progressChan)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"Ошибка при получении файла:\", err)\n\t\t\t\t\terrChan <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdone <- filePaths\n\t\t\t}()\n\t\t}\n\n\tdefault:\n\t\terr = errors.New(\"неопознанный флаг для печати\")\n\t\tif err != nil {\n\t\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = WaitReadyFile(ctx, bot, chatId, progressChan, done, errChan)\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\tif flag == OZON.NewLabels && len(newOrders.Result.PostingsFBS) > 0 {\n\t\torders := make([]db.Order, 0, len(newOrders.Result.PostingsFBS))\n\n\t\tfor _, order := range newOrders.Result.PostingsFBS {\n\t\t\torders = append(orders, db.Order{\n\t\t\t\tPostingNumber: order.PostingNumber,\n\t\t\t\tMarketplace:   \"ozon\",\n\t\t\t})\n\t\t}\n\n\t\tresult = m.db.Create(orders)\n\t\tif result.Error != nil {\n\t\t\t_, err = SendTextMessage(ctx, bot, chatId, result.Error.Error())\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tfbsPrinter.CleanFiles()\n}\n\nfunc (m *Manager) ozonClustersHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tclusters := m.ozonService.GetStocksManager().GetClusters()\n\n\tfmt.Println(clusters.Clusters)\n}\n\nfunc generateExcelOzon(postings map[string]map[string]map[string]int, stocks map[string]map[string]OZON.CustomStocks, K float64, mp string) (string, error) {\n\tfile := excelize.NewFile()\n\n\terr := createFullStatistic(postings, stocks, file)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor cluster, _ := range postings {\n\t\terr = createStatisticByCluster(cluster, postings, stocks, file)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tfilePath := mp + \"_stock_analysis.xlsx\"\n\tif err = file.SaveAs(filePath); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn filePath, nil\n}\n\nfunc createFullStatistic(postings map[string]map[string]map[string]int, stocks map[string]map[string]OZON.CustomStocks, file *excelize.File) error {\n\tsheetName := \"Общая статистика\"\n\tfile.SetSheetName(\"Sheet1\", sheetName)\n\n\tdates := make([]string, 0, 14)\n\tfor i := 14; i > 0; i-- {\n\t\tdate := time.Now().AddDate(0, 0, -i).Format(\"2006-01-02\")\n\t\tdates = append(dates, date)\n\t}\n\n\theaders := []string{\"Кластер\", \"Артикул\", \"Заказано\", \"Доступно, шт\", \"В пути, шт\", \"Спрос (прогноз)\"}\n\tfor i, h := range headers {\n\t\tcell := string(rune('A'+i)) + \"1\"\n\t\tfile.SetCellValue(sheetName, cell, h)\n\t\terr := file.SetColWidth(sheetName, string(rune('A'+i)), string(rune('A'+i)), float64(len(h)))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"ошибка настройки ширины колонки %s: %v\", string(rune('A'+i)), err)\n\t\t}\n\t}\n\n\t// все уникальные артикулы\n\tarticles := make(map[string]struct{})\n\tfor _, postingsMap := range postings {\n\t\tfor article := range postingsMap {\n\t\t\tarticles[article] = struct{}{}\n\t\t}\n\t}\n\tfor _, stocksMap := range stocks {\n\t\tfor article := range stocksMap {\n\t\t\tarticles[article] = struct{}{}\n\t\t}\n\t}\n\n\trow := 2\n\tfor cluster, postingsMap := range postings {\n\t\tfor article := range articles {\n\t\t\tsalesData := make([]float64, 0, 14)\n\t\t\ttotalOrdered := 0\n\n\t\t\tfor _, date := range dates {\n\t\t\t\tif qty, exists := postingsMap[article][date]; exists {\n\t\t\t\t\tsalesData = append(salesData, float64(qty))\n\t\t\t\t\ttotalOrdered += qty\n\t\t\t\t} else {\n\t\t\t\t\tsalesData = append(salesData, 0)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforecast := calculateSmartDemandForecast(salesData)\n\n\t\t\tavailableStockCount := 0\n\t\t\tinWayStockCount := 0\n\t\t\tif clusterStocks, stocksExists := stocks[cluster]; stocksExists {\n\t\t\t\tif stock, articleExists := clusterStocks[article]; articleExists {\n\t\t\t\t\tavailableStockCount = stock.AvailableStockCount\n\t\t\t\t\tinWayStockCount = stock.TransitStockCount + stock.RequestedStockCount\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfile.SetCellValue(sheetName, \"A\"+strconv.Itoa(row), cluster)\n\t\t\tfile.SetCellValue(sheetName, \"B\"+strconv.Itoa(row), article)\n\t\t\tfile.SetCellValue(sheetName, \"C\"+strconv.Itoa(row), totalOrdered)\n\t\t\tfile.SetCellValue(sheetName, \"D\"+strconv.Itoa(row), availableStockCount)\n\t\t\tfile.SetCellValue(sheetName, \"E\"+strconv.Itoa(row), inWayStockCount)\n\t\t\tfile.SetCellValue(sheetName, \"F\"+strconv.Itoa(row), forecast)\n\n\t\t\trow++\n\t\t}\n\t}\n\n\trangeRef := fmt.Sprintf(\"A1:F%d\", row-1)\n\terr := file.AutoFilter(sheetName, rangeRef, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\nfunc createStatisticByCluster(cluster string, postings map[string]map[string]map[string]int, stocks map[string]map[string]OZON.CustomStocks, file *excelize.File) error {\n\tsheetName := cluster\n\tfile.NewSheet(sheetName)\n\n\theaders := []string{\"артикул\", \"имя (необязательно)\", \"количество\"}\n\tfor i, h := range headers {\n\t\tcell := string(rune('A'+i)) + \"1\"\n\t\tfile.SetCellValue(sheetName, cell, h)\n\t}\n\n\t// все уникальные артикулы\n\tarticles := make(map[string]struct{})\n\tfor _, postingsMap := range postings {\n\t\tfor article := range postingsMap {\n\t\t\tarticles[article] = struct{}{}\n\t\t}\n\t}\n\tfor _, stocksMap := range stocks {\n\t\tfor article := range stocksMap {\n\t\t\tarticles[article] = struct{}{}\n\t\t}\n\t}\n\n\tdates := make([]string, 0, 14)\n\tfor i := 14; i > 0; i-- {\n\t\tdate := time.Now().AddDate(0, 0, -i).Format(\"2006-01-02\")\n\t\tdates = append(dates, date)\n\t}\n\n\trow := 2\n\tpostingsMap := postings[cluster]\n\tfor article := range articles {\n\t\tsalesData := make([]float64, 0, 14)\n\t\ttotalOrdered := 0\n\n\t\tfor _, date := range dates {\n\t\t\tif qty, exists := postingsMap[article][date]; exists {\n\t\t\t\tsalesData = append(salesData, float64(qty))\n\t\t\t\ttotalOrdered += qty\n\t\t\t} else {\n\t\t\t\tsalesData = append(salesData, 0)\n\t\t\t}\n\t\t}\n\n\t\tavailableStockCount := 0\n\t\tinWayStockCount := 0\n\t\tif clusterStocks, stocksExists := stocks[cluster]; stocksExists {\n\t\t\tif stock, articleExists := clusterStocks[article]; articleExists {\n\t\t\t\tavailableStockCount = stock.AvailableStockCount\n\t\t\t\tinWayStockCount = stock.TransitStockCount + stock.RequestedStockCount\n\t\t\t}\n\t\t}\n\n\t\tforecast := calculateSmartDemandForecast(salesData)\n\n\t\tif forecast > float64(availableStockCount+inWayStockCount) && forecast != 0 {\n\t\t\tfile.SetCellValue(sheetName, \"A\"+strconv.Itoa(row), article)\n\t\t\tfile.SetCellValue(sheetName, \"B\"+strconv.Itoa(row), \"\")\n\t\t\tfile.SetCellValue(sheetName, \"C\"+strconv.Itoa(row), forecast-float64(availableStockCount+inWayStockCount))\n\n\t\t\trow++\n\t\t}\n\n\t}\n\n\tif err := autoFitColumns(file, sheetName, []string{\"A\", \"B\", \"C\"}); err != nil {\n\t\treturn fmt.Errorf(\"ошибка автоподбора ширины: %v\", err)\n\t}\n\treturn nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/bot/handlers/handlers_ozon.go b/pkg/bot/handlers/handlers_ozon.go
--- a/pkg/bot/handlers/handlers_ozon.go	(revision 76331fc796c31feeabbf5b931123bab78482938b)
+++ b/pkg/bot/handlers/handlers_ozon.go	(date 1751529182560)
@@ -13,7 +13,7 @@
 	"strings"
 	"time"
 	"tradebot/api/ozon"
-	"tradebot/db"
+	"tradebot/pkg/db"
 	"tradebot/pkg/fbsPrinter"
 	"tradebot/pkg/marketplaces/OZON"
 )
Index: pkg/bot/handlers/handlers_default.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bot\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tbotlib \"github.com/go-telegram/bot\"\n\t\"github.com/go-telegram/bot/models\"\n\t\"github.com/joho/godotenv\"\n\t\"github.com/xuri/excelize/v2\"\n\t\"gorm.io/gorm\"\n\t\"log\"\n\t\"math\"\n\t\"os\"\n\tdb2 \"tradebot/db\"\n\t\"tradebot/pkg/fbsPrinter\"\n\t\"tradebot/pkg/marketplaces/OZON\"\n\t\"tradebot/pkg/marketplaces/WB\"\n\t\"tradebot/pkg/marketplaces/YANDEX\"\n)\n\nconst (\n\tCallbackStartHandler = \"START\"\n\n\tCallbackWbHandler                = \"WB\"\n\tCallbackYandexHandler            = \"YANDEX\"\n\tCallbackOzonHandler              = \"OZON\"\n\tCallbackWbFbsHandler             = \"WB-FBS\"\n\tCallbackYandexFbsHandler         = \"YANDEX-FBS\"\n\tCallbackWbOrdersHandler          = \"WB-ORDERS\"\n\tCallbackYandexOrdersHandler      = \"YANDEX-ORDERS\"\n\tCallbackOzonOrdersHandler        = \"OZON-ORDERS_\"\n\tCallbackOzonStocksHandler        = \"OZON-STOCKS_\"\n\tCallbackWbStocksHandler          = \"WB-STOCKS\"\n\tCallbackOzonStickersHandler      = \"OZON-STICKERS_\"\n\tCallbackOzonPrintStickersHandler = \"OZON-PRINT-STICKERS_\"\n\tCallbackClustersHandler          = \"OZON-CLUSTERS\"\n\tCallbackOzonCabinetsHandler      = \"OZON-CABINETS\"\n\tCallbackSelectCabinetHandler     = \"CABINET_\"\n)\n\ntype Manager struct {\n\tb             *botlib.Bot\n\tdb            *gorm.DB\n\tozonService   OZON.Service\n\twbService     WB.Service\n\tyandexService YANDEX.Service\n\tmyChatId      string\n}\n\nfunc NewBotManager(wbService WB.Service, yandexService YANDEX.Service, db *gorm.DB, myChatId string) *Manager {\n\treturn &Manager{\n\t\twbService:     wbService,\n\t\tyandexService: yandexService,\n\t\tdb:            db,\n\t\tmyChatId:      myChatId,\n\t}\n}\n\nfunc (m *Manager) SetBot(bot *botlib.Bot) {\n\tm.b = bot\n}\nfunc (m *Manager) GetBot() *botlib.Bot {\n\treturn m.b\n}\n\nfunc (m *Manager) RegisterBotHandlers() {\n\tm.b.RegisterHandler(botlib.HandlerTypeMessageText, \"/start\", botlib.MatchTypePrefix, m.startHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackStartHandler, botlib.MatchTypePrefix, m.startHandler)\n\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackWbHandler, botlib.MatchTypeExact, wbHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackYandexHandler, botlib.MatchTypeExact, m.yandexHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackOzonHandler, botlib.MatchTypeExact, m.ozonHandler)\n\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackWbFbsHandler, botlib.MatchTypeExact, m.wbFbsHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackYandexFbsHandler, botlib.MatchTypeExact, m.yandexFbsHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackWbOrdersHandler, botlib.MatchTypePrefix, m.wbOrdersHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackYandexOrdersHandler, botlib.MatchTypePrefix, m.yandexOrdersHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackOzonOrdersHandler, botlib.MatchTypePrefix, m.ozonOrdersHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackOzonStocksHandler, botlib.MatchTypePrefix, m.ozonStocksHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackWbStocksHandler, botlib.MatchTypePrefix, wbStocksHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackOzonStickersHandler, botlib.MatchTypePrefix, m.ozonStickersHandler)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackOzonPrintStickersHandler, botlib.MatchTypePrefix, m.ozonPrintStickers)\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackClustersHandler, botlib.MatchTypePrefix, m.ozonClustersHandler)\n\n\tm.b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, CallbackSelectCabinetHandler, botlib.MatchTypePrefix, m.ozonCabinetHandler)\n\n\t//b.RegisterHandler(botlib.HandlerTypeCallbackQueryData, \"YANDEX_FBS\", botlib.MatchTypePrefix, wbOrdersHandler)\n\n}\n\nfunc (m *Manager) DefaultHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.Message.From.ID\n\tmessage := update.Message.Text\n\n\tvar user db2.User\n\t// Смотрим есть ли артикул в бд\n\tresult := m.db.Where(`\"tgId\" = ?`, chatId).Find(&user)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding user:\", result.Error)\n\t}\n\n\tswitch user.StatusId {\n\tcase db2.EnabledStatus:\n\t\t{\n\t\t\tSendTextMessage(ctx, bot, chatId, \"Не понял тебя. Нажми /start еще раз\")\n\t\t}\n\tcase db2.WaitingWbState:\n\t\t{\n\t\t\tm.getWbFbs(ctx, bot, chatId, message)\n\t\t}\n\tcase db2.WaitingYaState:\n\t\t{\n\t\t\tm.getYandexFbs(ctx, bot, chatId, message)\n\t\t}\n\tdefault:\n\t\tpanic(\"unhandled default case\")\n\t}\n\n\terr := m.db.Model(&db2.User{}).Where(`\"tgId\" = ?`, chatId).Updates(db2.User{\n\t\tTgId:     chatId,\n\t\tStatusId: db2.EnabledStatus,\n\t}).Error\n\tif err != nil {\n\t\tlog.Println(\"Ошибка обновления EnabledStatus пользователя: \", err)\n\t}\n\tlog.Printf(\"У пользователя %v обновлен EnabledStatus\", chatId)\n\n}\n\nfunc createStartAdminMarkup() (string, models.InlineKeyboardMarkup) {\n\tstartMessage := \"Выбери маркетплейс для работы\"\n\tvar buttonsRow []models.InlineKeyboardButton\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"ВБ\", CallbackData: CallbackWbHandler})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"ЯНДЕКС\", CallbackData: CallbackYandexHandler})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"ОЗОН\", CallbackData: CallbackOzonHandler})\n\tallButtons := [][]models.InlineKeyboardButton{buttonsRow}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\treturn startMessage, markup\n}\n\nfunc createStartUserMarkup() (string, models.InlineKeyboardMarkup) {\n\tstartMessage := \"Для доступа к функционалу бота пиши @molchanovz. А пока можешь перейти в наши магазины\"\n\tvar buttonsRow []models.InlineKeyboardButton\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"ВБ\", URL: \"https://www.wildberries.ru/seller/27566\"})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"ЯНДЕКС\", URL: \"https://market.yandex.ru/business--metr-v-kube/3697903\"})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"ОЗОН\", URL: \"https://www.ozon.ru/seller/metr-v-kube-259267\"})\n\tallButtons := [][]models.InlineKeyboardButton{buttonsRow}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\treturn startMessage, markup\n}\n\nfunc (m *Manager) startHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tvar chatId int64\n\tvar text string\n\n\tif update.Message != nil {\n\t\tchatId = update.Message.From.ID\n\t} else {\n\t\tchatId = update.CallbackQuery.From.ID\n\t}\n\n\tvar user db2.User\n\t// Смотрим есть ли юзер в бд\n\tresult := m.db.Where(`\"tgId\" = ?`, chatId).Find(&user)\n\tif result.Error != nil {\n\t\tlog.Println(\"Error finding chatId: \", result.Error)\n\t}\n\n\t// если юзера нет - заполняем бд\n\tif user.TgId == 0 {\n\t\tuser = db2.User{TgId: chatId, StatusId: db2.EnabledStatus}\n\t\terr := m.db.Create(&user).Error\n\t\tif err != nil {\n\t\t\tlog.Println(\"Ошибка создания пользователя: \", err)\n\t\t}\n\t\tlog.Printf(\"Пользователь %v создан\", chatId)\n\t} else {\n\t\terr := m.db.Model(&db2.User{}).Where(`\"tgId\" = ?`, chatId).Updates(db2.User{\n\t\t\tStatusId: db2.EnabledStatus,\n\t\t}).Error\n\t\tif err != nil {\n\t\t\tlog.Println(\"Ошибка обновления EnabledStatus пользователя: \", err)\n\t\t}\n\t\tlog.Printf(\"У пользователя %v обновлен EnabledStatus\", chatId)\n\t}\n\n\tvar startMessage string\n\tvar markup models.InlineKeyboardMarkup\n\n\tif user.IsAdmin {\n\t\tstartMessage, markup = createStartAdminMarkup()\n\t} else {\n\t\tstartMessage, markup = createStartUserMarkup()\n\t}\n\n\tif update.Message != nil {\n\t\tname := update.Message.From.FirstName\n\t\ttext = fmt.Sprintf(\"Привет, %v. %v\", name, startMessage)\n\t\t_, err := bot.SendMessage(ctx, &botlib.SendMessageParams{ChatID: chatId, Text: text, ReplyMarkup: markup})\n\t\tif err != nil {\n\t\t\tlog.Println(fmt.Sprintf(\"ошибка отправки сообщения %v\", err))\n\t\t\treturn\n\t\t}\n\n\t} else {\n\t\tmessageId := update.CallbackQuery.Message.Message.ID\n\t\ttext = startMessage\n\t\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{MessageID: messageId, ChatID: chatId, Text: text, ReplyMarkup: markup})\n\t\tif err != nil {\n\t\t\tlog.Printf(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc WaitReadyFile(ctx context.Context, bot *botlib.Bot, chatId int64, progressChan chan fbsPrinter.Progress, done chan []string, errChan chan error) error {\n\tvar progressMsgId int\n\tvar lastReportedCurrent int\n\tvar lastTotal int\n\tvar err error\n\tfor {\n\t\tselect {\n\t\tcase progress := <-progressChan:\n\t\t\tprogressMsgId, err = sendProgress(ctx, bot, chatId, progress, lastReportedCurrent, lastTotal, progressMsgId)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\tcase filePath := <-done:\n\t\t\terr = sendFiles(ctx, bot, chatId, filePath, progressMsgId)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\n\t\tcase err = <-errChan:\n\t\t\t_, err = bot.SendMessage(ctx, &botlib.SendMessageParams{ChatID: chatId, Text: err.Error()})\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(fmt.Sprintf(\"ошибка отправки сообщения %v\", err))\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc sendFiles(ctx context.Context, bot *botlib.Bot, chatId int64, filePath []string, progressMsgId int) error {\n\t_, err := bot.SendChatAction(ctx, &botlib.SendChatActionParams{\n\t\tChatID: chatId,\n\t\tAction: models.ChatActionUploadDocument,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(filePath) == 0 {\n\t\treturn errors.New(\"новых заказов нет\")\n\t}\n\n\tfor _, batchPath := range filePath {\n\t\terr = SendMediaMessage(ctx, bot, chatId, batchPath)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif progressMsgId != 0 {\n\t\t_, err = bot.DeleteMessage(ctx, &botlib.DeleteMessageParams{\n\t\t\tChatID:    chatId,\n\t\t\tMessageID: progressMsgId,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ttext, markup := createStartAdminMarkup()\n\t_, err = bot.SendMessage(ctx, &botlib.SendMessageParams{\n\t\tChatID:      chatId,\n\t\tText:        text,\n\t\tReplyMarkup: markup,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc sendProgress(ctx context.Context, bot *botlib.Bot, chatId int64, progress fbsPrinter.Progress, lastReportedCurrent int, lastTotal int, progressMsgId int) (int, error) {\n\tif progress.Current != lastReportedCurrent || progress.Total != lastTotal {\n\t\tlastReportedCurrent = progress.Current\n\t\tlastTotal = progress.Total\n\n\t\ttext := fmt.Sprintf(\"Обработано заказов: %d из %d\", progress.Current, progress.Total)\n\n\t\tif progressMsgId == 0 {\n\t\t\tmsg, err := bot.SendMessage(ctx, &botlib.SendMessageParams{\n\t\t\t\tChatID: chatId,\n\t\t\t\tText:   text,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn 0, err\n\t\t\t} else {\n\t\t\t\tprogressMsgId = msg.ID\n\t\t\t}\n\t\t} else {\n\t\t\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{\n\t\t\t\tChatID:    chatId,\n\t\t\t\tMessageID: progressMsgId,\n\t\t\t\tText:      text,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t}\n\treturn progressMsgId, nil\n}\n\nfunc SendTextMessage(ctx context.Context, bot *botlib.Bot, chatId int64, text string) (*models.Message, error) {\n\tmessage, err := bot.SendMessage(ctx, &botlib.SendMessageParams{ChatID: chatId, Text: text})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn message, nil\n}\n\nfunc SendMediaMessage(ctx context.Context, bot *botlib.Bot, chatId int64, filePath string) error {\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinputFile := models.InputFileUpload{\n\t\tFilename: filePath,\n\t\tData:     file,\n\t}\n\n\t_, err = bot.SendDocument(ctx, &botlib.SendDocumentParams{ChatID: chatId, Document: &inputFile})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc initEnv(path, name string) (string, error) {\n\terr := godotenv.Load(path)\n\tif err != nil {\n\t\tlog.Printf(\"Ошибка загрузки файла %s: %v\\n\", path, err)\n\t\treturn \"\", fmt.Errorf(\"ошибка загрузки файла \" + path)\n\t}\n\t// Получаем значения переменных среды\n\tenv := os.Getenv(name)\n\n\tif env == \"\" {\n\t\treturn \"\", fmt.Errorf(\"переменная среды \" + name + \" не установлена\")\n\t}\n\treturn env, err\n}\n\n// Функция для автоподбора ширины колонок\nfunc autoFitColumns(f *excelize.File, sheet string, columns []string) error {\n\tfor _, col := range columns {\n\t\tmaxWidth := 8.0 // Минимальная ширина по умолчанию\n\t\trows, err := f.GetRows(sheet)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Находим максимальную длину содержимого в колонке\n\t\tfor _, row := range rows {\n\t\t\tcolIdx := int(col[0] - 'A')\n\t\t\tif colIdx < len(row) {\n\t\t\t\tcellValue := row[colIdx]\n\t\t\t\t// Учитываем длину текста + 2 символа для отступов\n\t\t\t\twidth := float64(len(cellValue))*1.1 + 2\n\t\t\t\tif width > maxWidth {\n\t\t\t\t\tmaxWidth = width\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Устанавливаем ширину\n\t\tif err := f.SetColWidth(sheet, col, col, maxWidth); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc calculateSmartDemandForecast(salesData []float64) float64 {\n\tif len(salesData) == 0 {\n\t\treturn 0\n\t}\n\n\t// Настройки\n\tconst (\n\t\tshortWindow = 4  // Анализ последних 4 дней для \"горячего\" тренда\n\t\tlongWindow  = 14 // Анализ за 14 дней для базового уровня\n\t)\n\n\t// \"горячий\" тренд (последние 4 дня)\n\thotTrend := 0.0\n\tif len(salesData) >= shortWindow {\n\t\trecent := salesData[len(salesData)-shortWindow:]\n\t\tfirst, last := recent[0], recent[len(recent)-1]\n\t\tif first > 0 {\n\t\t\thotTrend = last / first // Рост в последние дни\n\t\t}\n\t}\n\n\t//Среднее за весь период (14 дней)\n\tfullPeriodAverage := mean(salesData)\n\n\t//Среднее за последние 4 дня\n\trecentAverage := 0.0\n\tif len(salesData) >= shortWindow {\n\t\trecentAverage = mean(salesData[len(salesData)-shortWindow:])\n\t} else {\n\t\trecentAverage = mean(salesData)\n\t}\n\n\t// Динамический вес для тренда\n\ttrendWeight := 0.5  // Базовый вес тренда\n\tif hotTrend > 2.0 { // Если рост более 2x\n\t\ttrendWeight = 0.8 // Сильнее учитываем тренд\n\t}\n\n\t// Комбинированный прогноз\n\tforecast := (recentAverage*trendWeight + fullPeriodAverage*(1-trendWeight)) * float64(longWindow)\n\n\t// Гарантия, что прогноз не ниже последних продаж\n\tif len(salesData) > 0 {\n\t\tlastDaySales := salesData[len(salesData)-1]\n\t\tminForecast := lastDaySales * float64(longWindow) * 0.7 // Не менее 70% от последнего дня\n\t\tif forecast < minForecast {\n\t\t\tforecast = minForecast\n\t\t}\n\t}\n\n\treturn math.Round(forecast)\n}\n\nfunc mean(values []float64) float64 {\n\tsum := 0.0\n\tfor _, v := range values {\n\t\tsum += v\n\t}\n\treturn sum / float64(len(values))\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/bot/handlers/handlers_default.go b/pkg/bot/handlers/handlers_default.go
--- a/pkg/bot/handlers/handlers_default.go	(revision 76331fc796c31feeabbf5b931123bab78482938b)
+++ b/pkg/bot/handlers/handlers_default.go	(date 1751529182562)
@@ -12,7 +12,7 @@
 	"log"
 	"math"
 	"os"
-	db2 "tradebot/db"
+	"tradebot/pkg/db"
 	"tradebot/pkg/fbsPrinter"
 	"tradebot/pkg/marketplaces/OZON"
 	"tradebot/pkg/marketplaces/WB"
@@ -93,7 +93,7 @@
 	chatId := update.Message.From.ID
 	message := update.Message.Text
 
-	var user db2.User
+	var user db.User
 	// Смотрим есть ли артикул в бд
 	result := m.db.Where(`"tgId" = ?`, chatId).Find(&user)
 	if result.Error != nil {
@@ -101,15 +101,15 @@
 	}
 
 	switch user.StatusId {
-	case db2.EnabledStatus:
+	case db.EnabledStatus:
 		{
 			SendTextMessage(ctx, bot, chatId, "Не понял тебя. Нажми /start еще раз")
 		}
-	case db2.WaitingWbState:
+	case db.WaitingWbState:
 		{
 			m.getWbFbs(ctx, bot, chatId, message)
 		}
-	case db2.WaitingYaState:
+	case db.WaitingYaState:
 		{
 			m.getYandexFbs(ctx, bot, chatId, message)
 		}
@@ -117,9 +117,9 @@
 		panic("unhandled default case")
 	}
 
-	err := m.db.Model(&db2.User{}).Where(`"tgId" = ?`, chatId).Updates(db2.User{
+	err := m.db.Model(&db.User{}).Where(`"tgId" = ?`, chatId).Updates(db.User{
 		TgId:     chatId,
-		StatusId: db2.EnabledStatus,
+		StatusId: db.EnabledStatus,
 	}).Error
 	if err != nil {
 		log.Println("Ошибка обновления EnabledStatus пользователя: ", err)
@@ -160,7 +160,7 @@
 		chatId = update.CallbackQuery.From.ID
 	}
 
-	var user db2.User
+	var user db.User
 	// Смотрим есть ли юзер в бд
 	result := m.db.Where(`"tgId" = ?`, chatId).Find(&user)
 	if result.Error != nil {
@@ -169,15 +169,15 @@
 
 	// если юзера нет - заполняем бд
 	if user.TgId == 0 {
-		user = db2.User{TgId: chatId, StatusId: db2.EnabledStatus}
+		user = db.User{TgId: chatId, StatusId: db.EnabledStatus}
 		err := m.db.Create(&user).Error
 		if err != nil {
 			log.Println("Ошибка создания пользователя: ", err)
 		}
 		log.Printf("Пользователь %v создан", chatId)
 	} else {
-		err := m.db.Model(&db2.User{}).Where(`"tgId" = ?`, chatId).Updates(db2.User{
-			StatusId: db2.EnabledStatus,
+		err := m.db.Model(&db.User{}).Where(`"tgId" = ?`, chatId).Updates(db.User{
+			StatusId: db.EnabledStatus,
 		}).Error
 		if err != nil {
 			log.Println("Ошибка обновления EnabledStatus пользователя: ", err)
Index: pkg/bot/handlers/handlers_wb.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bot\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tbotlib \"github.com/go-telegram/bot\"\n\t\"github.com/go-telegram/bot/models\"\n\t\"github.com/xuri/excelize/v2\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"tradebot/api/wb\"\n\tdb2 \"tradebot/db\"\n\t\"tradebot/pkg/fbsPrinter\"\n\t\"tradebot/pkg/marketplaces/OZON\"\n\t\"tradebot/pkg/marketplaces/WB/wb_stocks_analyze\"\n)\n\nfunc wbHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\tmessageId := update.CallbackQuery.Message.Message.ID\n\n\ttext := \"Кабинет ВБ\"\n\n\tvar buttonsRow, buttonBack []models.InlineKeyboardButton\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Этикетки FBS\", CallbackData: CallbackWbFbsHandler})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Вчерашние заказы\", CallbackData: CallbackWbOrdersHandler})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Остатки\", CallbackData: CallbackWbStocksHandler})\n\n\tbuttonBack = append(buttonBack, models.InlineKeyboardButton{Text: \"Назад\", CallbackData: \"START\"})\n\n\tallButtons := [][]models.InlineKeyboardButton{buttonsRow, buttonBack}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\n\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{ChatID: chatId, MessageID: messageId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) wbFbsHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\terr := m.db.Model(&db2.User{}).Where(`\"tgId\" = ?`, chatId).Updates(db2.User{\n\t\tTgId:     chatId,\n\t\tStatusId: db2.WaitingWbState,\n\t}).Error\n\tif err != nil {\n\t\tlog.Println(\"Ошибка обновления WaitingWbState пользователя: \", err)\n\t}\n\tlog.Printf(\"У пользователя %v обновлен WaitingWbState\", chatId)\n\n\ttext := fmt.Sprintf(\"Отправь мне номер отгрузки\")\n\n\tvar buttonBack []models.InlineKeyboardButton\n\n\tbuttonBack = append(buttonBack, models.InlineKeyboardButton{Text: \"Назад\", CallbackData: \"START\"})\n\n\tallButtons := [][]models.InlineKeyboardButton{buttonBack}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\n\t_, err = bot.EditMessageText(ctx, &botlib.EditMessageTextParams{MessageID: update.CallbackQuery.Message.Message.ID, ChatID: chatId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) getWbFbs(ctx context.Context, bot *botlib.Bot, chatId int64, supplyId string) {\n\tdone := make(chan []string)\n\tprogressChan := make(chan fbsPrinter.Progress)\n\terrChan := make(chan error)\n\n\tdefer fbsPrinter.CleanFiles()\n\n\tgo func() {\n\t\tfilePath, err := m.wbService.GetStickersFbsManager().GetReadyFile(supplyId, progressChan)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Ошибка при получении файла:\", err)\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\tdone <- filePath\n\t}()\n\n\terr := WaitReadyFile(ctx, bot, chatId, progressChan, done, errChan)\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\tlog.Println(fmt.Sprintf(\"ошибка отправки сообщения %v\", err))\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) wbOrdersHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\terr := m.wbService.GetOrdersManager().WriteToGoogleSheets()\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tdate := time.Now().AddDate(0, 0, -OZON.OrdersDaysAgo)\n\t\t_, err = SendTextMessage(ctx, bot, chatId, fmt.Sprintf(\"Заказы вб за %v были внесены\", date))\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n}\nfunc wbStocksHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tdaysAgo := 14\n\tK := 100.0\n\n\tchatId := update.CallbackQuery.From.ID\n\n\tWbKey, err := initEnv(\".env\", \"API_KEY_WB\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\torders := wb_stocks_analyze.GetOrders(WbKey, daysAgo)\n\n\tstocks, lostWarehouses, err := wb_stocks_analyze.GetStocks(WbKey)\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, fmt.Sprintf(\"Ошибка при анализе остатков: %v\", err))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Ошибка отправки сообщения:\", err)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\tfilePath, err := generateExcelWB(orders, stocks, K, \"wb\")\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, fmt.Sprintf(\"Ошибка при генерации экселя: %v\", err))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Ошибка отправки сообщения:\", err)\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\terr = SendMediaMessage(ctx, bot, chatId, filePath)\n\tif err != nil {\n\t\tlog.Println(\"Ошибка отправки сообщения:\", err)\n\t\treturn\n\t}\n\tos.Remove(filePath)\n\n\tif len(lostWarehouses) > 0 {\n\t\twarehousesStr := strings.Builder{}\n\n\t\tfor warehouse := range lostWarehouses {\n\t\t\twarehousesStr.WriteString(warehouse + \"\\n\")\n\t\t}\n\t\t_, err := SendTextMessage(ctx, bot, chatId, fmt.Sprintf(\"Нужно добавить:\\n\"+warehousesStr.String()))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n}\n\nfunc (m *Manager) AnalyzeStocks(apiKey string, ctx context.Context, b *botlib.Bot) error {\n\tstocksFBO, err := wb.GetStockFbo(apiKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif stocksFBO == nil {\n\t\treturn errors.New(\"newStocks nil\")\n\t}\n\n\ttype customStock struct {\n\t\tstockFBO int\n\t\tstockFBS int\n\t}\n\n\tstocksMap := make(map[string]customStock)\n\n\t// Заполнение мапы артикулов\n\tfor i := range stocksFBO {\n\t\tif stock, hasArticle := stocksMap[stocksFBO[i].SupplierArticle]; hasArticle {\n\t\t\tstock.stockFBO += stocksFBO[i].Quantity\n\t\t\tstocksMap[stocksFBO[i].SupplierArticle] = stock\n\t\t} else {\n\t\t\tstock := customStock{\n\t\t\t\tstockFBO: stocksFBO[i].Quantity,\n\t\t\t}\n\t\t\tstocksMap[stocksFBO[i].SupplierArticle] = stock\n\t\t}\n\t}\n\n\tif len(stocksMap) == 0 {\n\t\treturn errors.New(\"stocksMap nil\")\n\t}\n\n\tfor article, newStocks := range stocksMap {\n\t\tvar stocksDB []db2.Stock\n\t\t// Смотрим есть ли артикул в бд\n\t\tresult := m.db.Where(\"article = ? and marketplace = ?\", article, \"wildberries\").Find(&stocksDB)\n\t\tif result.Error != nil {\n\t\t\treturn result.Error\n\t\t}\n\n\t\t// если артикула нет - заполняем бд\n\t\tif len(stocksDB) == 0 {\n\t\t\tstock := db2.Stock{Article: article, StocksFBO: &newStocks.stockFBO, UpdatedAt: time.Now(), Marketplace: \"wildberries\"}\n\t\t\terr = m.db.Create(&stock).Error\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif newStocks.stockFBO == *stocksDB[0].StocksFBO {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Если стало нулем\n\t\tif newStocks.stockFBO == 0 && *stocksDB[0].StocksFBO != 0 {\n\t\t\t// Отправляем уведомление\n\t\t\t_, err = b.SendMessage(ctx, &botlib.SendMessageParams{\n\t\t\t\tChatID:    m.myChatId,\n\t\t\t\tText:      fmt.Sprintf(\"На складе <b>WB</b> закончились <code>%v</code>. Проверьте FBS\", article),\n\t\t\t\tParseMode: models.ParseModeHTML,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tlog.Println(\"Обновляем \", stocksDB[0].Article)\n\n\t\terr = m.db.Model(&db2.Stock{}).Where(\"article = ? and marketplace = ?\", stocksDB[0].Article, \"wildberries\").Updates(db2.Stock{\n\t\t\tStocksFBO: &newStocks.stockFBO,\n\t\t\tUpdatedAt: time.Now(),\n\t\t}).Error\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc generateExcelWB(postings map[string]map[string]int, stocks map[string]map[string]int, K float64, mp string) (string, error) {\n\tfile := excelize.NewFile()\n\tsheetName := \"StocksFBO Analysis\"\n\tfile.SetSheetName(\"Sheet1\", sheetName)\n\n\t// Заголовки\n\theaders := []string{\"Кластер\", \"Артикул\", \"Заказано\", \"Остатки\"}\n\tfor i, h := range headers {\n\t\tcell := string(rune('A'+i)) + \"1\"\n\t\tfile.SetCellValue(sheetName, cell, h)\n\t}\n\n\tarticles := make(map[string]struct{})\n\n\t// Собираем все уникальные артикулы\n\tfor _, postingsMap := range postings {\n\t\tfor article := range postingsMap {\n\t\t\tarticles[article] = struct{}{}\n\t\t}\n\t}\n\tfor _, stocksMap := range stocks {\n\t\tfor article := range stocksMap {\n\t\t\tarticles[article] = struct{}{}\n\t\t}\n\t}\n\n\trow := 2\n\tfor cluster, postingsMap := range postings {\n\n\t\tfor article := range articles {\n\t\t\tpostingCount := postingsMap[article]\n\t\t\tstock := 0\n\t\t\tif clusterStocks, stocksExists := stocks[cluster]; stocksExists {\n\t\t\t\tstock = clusterStocks[article]\n\t\t\t}\n\n\t\t\tfile.SetCellValue(sheetName, \"A\"+strconv.Itoa(row), cluster)\n\t\t\tfile.SetCellValue(sheetName, \"B\"+strconv.Itoa(row), article)\n\t\t\tfile.SetCellValue(sheetName, \"C\"+strconv.Itoa(row), postingCount)\n\t\t\tfile.SetCellValue(sheetName, \"D\"+strconv.Itoa(row), stock)\n\t\t\trow++\n\n\t\t}\n\t}\n\n\topt := []excelize.AutoFilterOptions{{\n\t\tColumn:     \"\",\n\t\tExpression: \"\",\n\t}}\n\n\trangeRef := fmt.Sprintf(\"A1:A%v\", row)\n\n\terr := file.AutoFilter(sheetName, rangeRef, opt)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Сохраняем файл\n\tfilePath := mp + \"_stock_analysis.xlsx\"\n\tif err := file.SaveAs(filePath); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn filePath, nil\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/bot/handlers/handlers_wb.go b/pkg/bot/handlers/handlers_wb.go
--- a/pkg/bot/handlers/handlers_wb.go	(revision 76331fc796c31feeabbf5b931123bab78482938b)
+++ b/pkg/bot/handlers/handlers_wb.go	(date 1751529182553)
@@ -13,7 +13,7 @@
 	"strings"
 	"time"
 	"tradebot/api/wb"
-	db2 "tradebot/db"
+	"tradebot/pkg/db"
 	"tradebot/pkg/fbsPrinter"
 	"tradebot/pkg/marketplaces/OZON"
 	"tradebot/pkg/marketplaces/WB/wb_stocks_analyze"
@@ -46,9 +46,9 @@
 func (m *Manager) wbFbsHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {
 	chatId := update.CallbackQuery.From.ID
 
-	err := m.db.Model(&db2.User{}).Where(`"tgId" = ?`, chatId).Updates(db2.User{
+	err := m.db.Model(&db.User{}).Where(`"tgId" = ?`, chatId).Updates(db.User{
 		TgId:     chatId,
-		StatusId: db2.WaitingWbState,
+		StatusId: db.WaitingWbState,
 	}).Error
 	if err != nil {
 		log.Println("Ошибка обновления WaitingWbState пользователя: ", err)
@@ -210,7 +210,7 @@
 	}
 
 	for article, newStocks := range stocksMap {
-		var stocksDB []db2.Stock
+		var stocksDB []db.Stock
 		// Смотрим есть ли артикул в бд
 		result := m.db.Where("article = ? and marketplace = ?", article, "wildberries").Find(&stocksDB)
 		if result.Error != nil {
@@ -219,7 +219,7 @@
 
 		// если артикула нет - заполняем бд
 		if len(stocksDB) == 0 {
-			stock := db2.Stock{Article: article, StocksFBO: &newStocks.stockFBO, UpdatedAt: time.Now(), Marketplace: "wildberries"}
+			stock := db.Stock{Article: article, StocksFBO: &newStocks.stockFBO, UpdatedAt: time.Now(), Marketplace: "wildberries"}
 			err = m.db.Create(&stock).Error
 			if err != nil {
 				return err
@@ -247,7 +247,7 @@
 
 		log.Println("Обновляем ", stocksDB[0].Article)
 
-		err = m.db.Model(&db2.Stock{}).Where("article = ? and marketplace = ?", stocksDB[0].Article, "wildberries").Updates(db2.Stock{
+		err = m.db.Model(&db.Stock{}).Where("article = ? and marketplace = ?", stocksDB[0].Article, "wildberries").Updates(db.Stock{
 			StocksFBO: &newStocks.stockFBO,
 			UpdatedAt: time.Now(),
 		}).Error
Index: pkg/marketplaces/OZON/service.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package OZON\n\nimport (\n\t\"tradebot/db\"\n)\n\nconst (\n\tStocksDaysAgo = 14\n\tOrdersDaysAgo = 1\n\tspreadsheetId = \"1WOUHE2qs-c2idJN4pduWkT6PqJzX8XioI-I3ZoeGxMo\"\n)\n\ntype Authorization struct {\n\tClientId, Token string\n}\n\ntype Service struct {\n\tAuthorization\n\tspreadsheetId string\n}\n\nfunc NewService(cabinet db.Cabinet) Service {\n\tservice := Service{\n\t\tAuthorization: Authorization{\n\t\t\tClientId: cabinet.ClientId,\n\t\t\tToken:    cabinet.Key,\n\t\t},\n\t\tspreadsheetId: spreadsheetId,\n\t}\n\treturn service\n}\n\nfunc (s Service) GetOrdersAndReturnsManager() OrdersManager {\n\treturn NewOrdersManager(s.ClientId, s.Token, s.spreadsheetId, OrdersDaysAgo)\n\n}\n\nfunc (s Service) GetStocksManager() AnalyzeManager {\n\treturn NewAnalyzeManager(s.ClientId, s.Token, StocksDaysAgo)\n\n}\n\nfunc (s Service) GetStickersFBSManager(printedOrders map[string]struct{}) StickerManager {\n\treturn NewStickerManager(s.ClientId, s.Token, printedOrders)\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/marketplaces/OZON/service.go b/pkg/marketplaces/OZON/service.go
--- a/pkg/marketplaces/OZON/service.go	(revision 76331fc796c31feeabbf5b931123bab78482938b)
+++ b/pkg/marketplaces/OZON/service.go	(date 1751529182557)
@@ -1,7 +1,7 @@
 package OZON
 
 import (
-	"tradebot/db"
+	"tradebot/pkg/db"
 )
 
 const (
Index: pkg/bot/handlers/handlers_yandex.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package bot\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\tbotlib \"github.com/go-telegram/bot\"\n\t\"github.com/go-telegram/bot/models\"\n\t\"log\"\n\tdb2 \"tradebot/db\"\n\t\"tradebot/pkg/fbsPrinter\"\n\t\"tradebot/pkg/marketplaces/YANDEX/yandex_stickers_fbs\"\n)\n\nfunc (m *Manager) yandexHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\tmessageId := update.CallbackQuery.Message.Message.ID\n\n\ttext := \"Кабинет Яндекс\"\n\n\tvar buttonsRow, buttonBack []models.InlineKeyboardButton\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Этикетки FBS\", CallbackData: CallbackYandexFbsHandler})\n\tbuttonsRow = append(buttonsRow, models.InlineKeyboardButton{Text: \"Вчерашние заказы\", CallbackData: CallbackYandexOrdersHandler})\n\n\tbuttonBack = append(buttonBack, models.InlineKeyboardButton{Text: \"Назад\", CallbackData: \"START\"})\n\n\tallButtons := [][]models.InlineKeyboardButton{buttonsRow, buttonBack}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\n\t_, err := bot.EditMessageText(ctx, &botlib.EditMessageTextParams{ChatID: chatId, MessageID: messageId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) yandexFbsHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\terr := m.db.Model(&db2.User{}).Where(`\"tgId\" = ?`, chatId).Updates(db2.User{\n\t\tTgId:     chatId,\n\t\tStatusId: db2.WaitingYaState,\n\t}).Error\n\tif err != nil {\n\t\tlog.Println(\"Ошибка обновления WaitingYaState пользователя: \", err)\n\t}\n\tlog.Printf(\"У пользователя %v обновлен WaitingYaState\", chatId)\n\n\ttext := fmt.Sprintf(\"Отправь мне номер отгрузки\")\n\tvar buttonBack []models.InlineKeyboardButton\n\n\tbuttonBack = append(buttonBack, models.InlineKeyboardButton{Text: \"Назад\", CallbackData: \"START\"})\n\n\tallButtons := [][]models.InlineKeyboardButton{buttonBack}\n\tmarkup := models.InlineKeyboardMarkup{InlineKeyboard: allButtons}\n\n\t_, err = bot.EditMessageText(ctx, &botlib.EditMessageTextParams{MessageID: update.CallbackQuery.Message.Message.ID, ChatID: chatId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) yandexOrdersHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {\n\tchatId := update.CallbackQuery.From.ID\n\n\terr := m.yandexService.GetOrdersAndReturnsManager().WriteToGoogleSheets()\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\t_, err = SendTextMessage(ctx, bot, chatId, \"Заказы яндекс за вчерашний день были внесены\")\n\tif err != nil {\n\t\tlog.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n}\n\nfunc (m *Manager) getYandexFbsDEPRECATED(ctx context.Context, bot *botlib.Bot, chatId int64, supplyId string) {\n\ttext := fmt.Sprintf(\"Подготовка файла Яндекс\")\n\tmessage, err := SendTextMessage(ctx, bot, chatId, text)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = m.yandexService.GetStickersFbsManager().GetOrdersInfo(supplyId, nil)\n\tif err != nil {\n\t\t_, err := SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tfilePath := fmt.Sprintf(\"%v.pdf\", yandex_stickers_fbs.YaDirectoryPath+supplyId)\n\t\tSendMediaMessage(ctx, bot, chatId, filePath)\n\t\tyandex_stickers_fbs.CleanFiles(supplyId)\n\t}\n\n\ttext, markup := createStartAdminMarkup()\n\t_, err = bot.SendMessage(ctx, &botlib.SendMessageParams{ChatID: chatId, Text: text, ReplyMarkup: markup})\n\tif err != nil {\n\t\tlog.Println(fmt.Sprintf(\"ошибка отправки сообщения %v\", err))\n\t\treturn\n\t}\n\n\t_, err = bot.DeleteMessage(ctx, &botlib.DeleteMessageParams{ChatID: chatId, MessageID: message.ID})\n\tif err != nil {\n\t\treturn\n\t}\n\n}\nfunc (m *Manager) getYandexFbs(ctx context.Context, bot *botlib.Bot, chatId int64, supplyId string) {\n\n\tdone := make(chan []string)\n\tprogressChan := make(chan fbsPrinter.Progress)\n\terrChan := make(chan error)\n\tvar filePaths []string\n\n\tgo func() {\n\t\tfilePath, err := m.yandexService.GetStickersFbsManager().GetOrdersInfo(supplyId, progressChan)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Ошибка при получении файла:\", err)\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\n\t\tfilePaths = append(filePaths, filePath)\n\n\t\tdone <- filePaths\n\t}()\n\n\terr := WaitReadyFile(ctx, bot, chatId, progressChan, done, errChan)\n\tif err != nil {\n\t\t_, err = SendTextMessage(ctx, bot, chatId, err.Error())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/bot/handlers/handlers_yandex.go b/pkg/bot/handlers/handlers_yandex.go
--- a/pkg/bot/handlers/handlers_yandex.go	(revision 76331fc796c31feeabbf5b931123bab78482938b)
+++ b/pkg/bot/handlers/handlers_yandex.go	(date 1751529182548)
@@ -6,7 +6,7 @@
 	botlib "github.com/go-telegram/bot"
 	"github.com/go-telegram/bot/models"
 	"log"
-	db2 "tradebot/db"
+	"tradebot/pkg/db"
 	"tradebot/pkg/fbsPrinter"
 	"tradebot/pkg/marketplaces/YANDEX/yandex_stickers_fbs"
 )
@@ -37,9 +37,9 @@
 func (m *Manager) yandexFbsHandler(ctx context.Context, bot *botlib.Bot, update *models.Update) {
 	chatId := update.CallbackQuery.From.ID
 
-	err := m.db.Model(&db2.User{}).Where(`"tgId" = ?`, chatId).Updates(db2.User{
+	err := m.db.Model(&db.User{}).Where(`"tgId" = ?`, chatId).Updates(db.User{
 		TgId:     chatId,
-		StatusId: db2.WaitingYaState,
+		StatusId: db.WaitingYaState,
 	}).Error
 	if err != nil {
 		log.Println("Ошибка обновления WaitingYaState пользователя: ", err)
Index: pkg/app/app.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package app\n\nimport (\n\t\"fmt\"\n\t\"github.com/joho/godotenv\"\n\t\"gorm.io/gorm\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"tradebot/db\"\n\t\"tradebot/pkg/bot\"\n\t\"tradebot/pkg/marketplaces/WB\"\n\t\"tradebot/pkg/marketplaces/YANDEX\"\n\t\"tradebot/pkg/scheduler\"\n)\n\ntype Application struct {\n\tenvPath string\n}\n\nfunc New(envPath string) Application {\n\treturn Application{envPath: envPath}\n}\n\nfunc (a Application) Start() {\n\tmyChatId, err := initEnv(a.envPath, \"myChatId\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\n\tdsn, err := initEnv(a.envPath, \"DSN\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\tdataBaseService := db.NewService(dsn)\n\tsqlDB, err := dataBaseService.InitDB()\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tif sqlDB == nil {\n\t\treturn\n\t}\n\n\twbToken, err := initEnv(a.envPath, \"API_KEY_WB\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\twbService := WB.NewService(wbToken)\n\n\tyandexCampaignIdFBO, err := initEnv(a.envPath, \"yandexCampaignIdFBO\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\tyandexCampaignIdFBS, err := initEnv(a.envPath, \"yandexCampaignIdFBS\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\tyandexToken, err := initEnv(a.envPath, \"yandexToken\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\tyandexService := YANDEX.NewService(yandexCampaignIdFBO, yandexCampaignIdFBS, yandexToken)\n\n\tbotToken, err := initEnv(a.envPath, \"token\")\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t}\n\tbotService := bot.NewBotService(*wbService, *yandexService, botToken, sqlDB, myChatId)\n\tbotService.Start()\n\n\tschedulerService := scheduler.NewService(botService.Manager(), wbToken)\n\terr = schedulerService.Start()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tdefer func(sqlDB *gorm.DB) {\n\n\t\tdatabase, err := sqlDB.DB()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\terr = database.Close()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Println(\"Соединение закрыто\")\n\t}(sqlDB)\n\n\tstopChan := make(chan os.Signal, 1)\n\tsignal.Notify(stopChan, os.Interrupt, syscall.SIGTERM)\n\n\t<-stopChan\n\tlog.Println(\"Завершение программы...\")\n}\n\nfunc initEnv(path, name string) (string, error) {\n\terr := godotenv.Load(path)\n\tif err != nil {\n\t\tlog.Printf(\"Ошибка загрузки файла %s: %v\\n\", path, err)\n\t\treturn \"\", fmt.Errorf(\"ошибка загрузки файла \" + path)\n\t}\n\t// Получаем значения переменных среды\n\tenv := os.Getenv(name)\n\n\tif env == \"\" {\n\t\treturn \"\", fmt.Errorf(\"переменная среды \" + name + \" не установлена\")\n\t}\n\treturn env, err\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/app/app.go b/pkg/app/app.go
--- a/pkg/app/app.go	(revision 76331fc796c31feeabbf5b931123bab78482938b)
+++ b/pkg/app/app.go	(date 1751529182555)
@@ -8,8 +8,8 @@
 	"os"
 	"os/signal"
 	"syscall"
-	"tradebot/db"
 	"tradebot/pkg/bot"
+	"tradebot/pkg/db"
 	"tradebot/pkg/marketplaces/WB"
 	"tradebot/pkg/marketplaces/YANDEX"
 	"tradebot/pkg/scheduler"
